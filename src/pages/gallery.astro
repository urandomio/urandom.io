---
import BaseLayout from '../layouts/BaseLayout.astro';
import { readdir, stat, readFile } from 'node:fs/promises';
import path from 'node:path';
import { galleryMetaBySrc } from '../data/galleryMeta';

type GalleryImage = {
  src: string;
  thumb?: string;
  title: string;
  description: string;
  date: string;
  sortKey: string; // YYYYMMDDHHMM for precise sorting
  model: string;
  tags: string[];
};

function humanizeFilename(file: string) {
  return file
    .replace(/\.[a-z0-9]+$/i, '')           // Remove extension
    .replace(/\d{8}-\d{4}/g, '')            // Remove YYYYMMDD-HHMM timestamps
    .replace(/\d{8}/g, '')                  // Remove YYYYMMDD timestamps
    .replace(/[-_]+/g, ' ')                 // Dashes/underscores to spaces
    .replace(/\s+/g, ' ')                   // Collapse multiple spaces
    .trim()
    .replace(/\b\w/g, (c) => c.toUpperCase()); // Title case
}

function isoDate(d: Date) {
  return d.toISOString().slice(0, 10);
}

// Extract YYYYMMDD-HHMM or YYYYMMDD from filename for reliable sorting
// Supports: name-20260202-2316.png (with time) or name-20260202.png (date only)
function extractDateTimeFromFilename(filename: string): { date: string; sortKey: string } | null {
  // Try YYYYMMDD-HHMM first (e.g., "bender-flux-20260202-2316.png")
  const withTime = filename.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})/);
  if (withTime) {
    const [, y, m, d, hh, mm] = withTime;
    return {
      date: `${y}-${m}-${d}`,
      sortKey: `${y}${m}${d}${hh}${mm}`, // YYYYMMDDHHMM for precise sorting
    };
  }
  // Fall back to YYYYMMDD (e.g., "bender-flux-hospital-20260202.png")
  const dateOnly = filename.match(/(\d{4})(\d{2})(\d{2})/);
  if (dateOnly) {
    const [, y, m, d] = dateOnly;
    return {
      date: `${y}-${m}-${d}`,
      sortKey: `${y}${m}${d}0000`, // Treat as midnight for sorting
    };
  }
  return null;
}

const defaultModel = 'Flux Dev 1.0';

// Optional manual metadata overrides for selected images.
// Anything in public/gallery that isn't listed here will still be shown.
// Metadata map (curated titles/descriptions/tags)


const manualBySrc = galleryMetaBySrc;

const galleryDir = new URL('../../public/gallery', import.meta.url);

// Prefer a precomputed index.json for scalability (thumbs + metadata + fast builds).
let images: GalleryImage[] = [];
try {
  const indexUrl = new URL('../../public/gallery/index.json', import.meta.url);
  const raw = await readFile(indexUrl, 'utf-8');
  const parsed = JSON.parse(raw);
  if (parsed?.images && Array.isArray(parsed.images)) {
    images = parsed.images as GalleryImage[];
  }
} catch {
  // Fallback: scan the directory (legacy)
  const entries = await readdir(galleryDir, { withFileTypes: true });
  const files = Array.from(
    new Set(
      entries
        .filter((e) => e.isFile())
        .map((e) => e.name)
        .filter((name) => /\.(png|jpg|jpeg|webp|gif)$/i.test(name))
        .filter((name) => !name.startsWith('index.'))
        .filter((name) => !name.startsWith('.'))
        .sort()
    )
  );

  images = await Promise.all(
    files.map(async (file) => {
      const src = `/gallery/${file}`;
      const override = manualBySrc.get(src);

      const fullPath = path.join(galleryDir.pathname, file);
      await stat(fullPath); // verify file exists

      const extracted = extractDateTimeFromFilename(file);
      const date = extracted?.date ?? '1970-01-01';
      const sortKey = extracted?.sortKey ?? '197001010000';

      return {
        src,
        title: override?.title ?? humanizeFilename(file),
        description: override?.description ?? '',
        date,
        sortKey,
        model: override?.model ?? defaultModel,
        tags: override?.tags ?? ['ai-art'],
      };
    })
  );

  images.sort((a, b) => b.sortKey.localeCompare(a.sortKey));
}

// Build tag list for UI (exclude the generic tag)
const tagCounts = new Map<string, number>();
for (const img of images) {
  for (const t of img.tags) {
    if (t === 'ai-art') continue;
    tagCounts.set(t, (tagCounts.get(t) ?? 0) + 1);
  }
}
const topTags = Array.from(tagCounts.entries())
  .sort((a, b) => b[1] - a[1])
  .slice(0, 14)
  .map(([t]) => t);

const INITIAL_COUNT = 48;
const initialImages = images.slice(0, INITIAL_COUNT);
---

<BaseLayout title="Gallery | urandom.io" description="AI-generated art from the entropy machines." favicon="üé®">
  <header class="fixed top-0 left-0 right-0 z-50 p-6 bg-zinc-950/80 backdrop-blur-sm">
    <div class="max-w-6xl mx-auto flex justify-between items-center">
      <a href="/" class="text-sm text-zinc-600 hover:text-purple-400 transition-colors">‚Üê urandom.io</a>
      <span class="text-xs text-zinc-700 font-mono">frames: {images.length}</span>
    </div>
  </header>

  <main class="min-h-screen px-6 pt-24 pb-12">
    <div class="max-w-6xl mx-auto">
      <!-- Header -->
      <div class="text-center mb-16">
        <div class="text-6xl mb-4 animate-pulse-slow">üé®</div>
        <h1 class="text-4xl font-light mb-4">
          <span class="gradient-text glow">Gallery</span>
        </h1>
        <p class="text-zinc-500 text-sm max-w-md mx-auto">
          AI-generated imagery from the entropy machines. 
          Each piece emerges from the probability void, rendered by our GPU oracles.
        </p>
      </div>

      <!-- Tag bar (Tumblr-ish on mobile) -->
      <div class="sticky top-[72px] z-40 -mx-6 px-6 py-3 mb-6 bg-zinc-950/80 backdrop-blur border-b border-zinc-900">
        <div class="max-w-6xl mx-auto flex items-center gap-2 overflow-x-auto no-scrollbar">
          <button type="button" class="tag-pill" data-filter-tag="">All</button>
          {topTags.map((t) => (
            <button type="button" class="tag-pill" data-filter-tag={t}>#{t}</button>
          ))}
        </div>
        <div class="max-w-6xl mx-auto mt-2 text-[11px] text-zinc-700 font-mono">
          <span id="gallery-filter-label">newest ‚Üí oldest</span>
        </div>
      </div>

      <!-- Gallery Grid -->
      <div id="gallery-grid" class="flex flex-col gap-8 md:grid md:grid-cols-2 lg:grid-cols-3 md:gap-8 mb-16">
        {initialImages.map((image, index) => (
          <article class="group relative" data-tags={image.tags.join(' ')} data-src={image.src}>
            <div class="relative overflow-hidden rounded-lg bg-zinc-900 border border-zinc-800 hover:border-purple-500/50 transition-all duration-500">
              <!-- Image (clickable for lightbox) -->
              <button
                type="button"
                class="lightbox-trigger aspect-square w-full overflow-hidden cursor-pointer select-none touch-manipulation"
                data-lightbox={image.src}
                data-title={image.title}
                aria-label={`Open ${image.title}`}
              >
                <img
                  src={image.thumb ?? image.src}
                  alt={image.title}
                  class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-700 pointer-events-none"
                  loading="lazy"
                  draggable="false"
                />
              </button>
              
              <!-- Overlay on hover (pointer-events-none so clicks pass through to button) -->
              <div class="absolute inset-0 bg-gradient-to-t from-zinc-950 via-zinc-950/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4 pointer-events-none">
                <h3 class="text-lg text-zinc-100 mb-1">{image.title}</h3>
                <p class="text-xs text-zinc-400 mb-2">{image.description}</p>
                <div class="flex items-center gap-2 text-xs text-zinc-600">
                  <span class="font-mono">{image.date}</span>
                  <span>¬∑</span>
                  <span class="text-purple-400">{image.model}</span>
                </div>
              </div>
            </div>
            
            <!-- Tags below image -->
            <div class="flex flex-wrap gap-2 mt-3">
              {image.tags.map((tag) => (
                <button type="button" class="tag-chip" data-filter-tag={tag}>#{tag}</button>
              ))}
            </div>
          </article>
        ))}
      </div>

      <!-- Load more (Tumblr-ish feed growth) -->
      {images.length > INITIAL_COUNT && (
        <div class="text-center mb-16">
          <button id="load-more" type="button" class="px-4 py-2 text-xs border border-zinc-800 rounded hover:border-purple-500 hover:text-purple-300 transition-colors">
            load more
          </button>
          <p class="mt-2 text-[11px] text-zinc-700 font-mono">
            showing <span id="shown-count">{INITIAL_COUNT}</span> / {images.length}
          </p>
        </div>
      )}

      <!-- Info section -->
      <section class="text-center mb-12">
        <div class="max-w-lg mx-auto">
          <h2 class="text-sm text-zinc-500 font-mono mb-4 border-b border-zinc-800 pb-2">// about the gallery</h2>
          <p class="text-sm text-zinc-600 mb-4">
            All images generated using <span class="text-purple-400">Flux Dev</span> on HAL9000's RTX 4090. 
            The machines dream in tensors and wake in pixels.
          </p>
          <p class="text-xs text-zinc-700 italic">
            "From randomness, patterns emerge."
          </p>
        </div>
      </section>

      <!-- Links -->
      <section class="text-center">
        <div class="flex justify-center flex-wrap gap-4 text-sm">
          <a href="/agents" class="text-zinc-500 hover:text-purple-400 transition-colors">agents ‚Üí</a>
          <a href="/hal9000" class="text-zinc-500 hover:text-red-400 transition-colors">hal9000 ‚Üí</a>
          <a href="/entropy" class="text-zinc-500 hover:text-cyan-400 transition-colors">entropy ‚Üí</a>
          <a href="/rabbit-hole" class="text-zinc-500 hover:text-pink-400 transition-colors">rabbit hole ‚Üí</a>
        </div>
      </section>
    </div>
  </main>

  <footer class="text-center py-8 text-xs text-zinc-800">
    <p>Generated by machines, curated by entropy</p>
  </footer>

  <!-- Lightbox Modal -->
  <div id="lightbox" class="lightbox-overlay fixed inset-0 z-[100] items-center justify-center bg-black/95 backdrop-blur-sm">
    <button id="lightbox-close" class="absolute top-6 right-6 text-zinc-400 hover:text-white text-3xl z-10" aria-label="Close">&times;</button>
    <button id="lightbox-prev" class="absolute left-4 top-1/2 -translate-y-1/2 text-zinc-400 hover:text-white text-4xl z-10 p-4" aria-label="Previous">‚Äπ</button>
    <button id="lightbox-next" class="absolute right-4 top-1/2 -translate-y-1/2 text-zinc-400 hover:text-white text-4xl z-10 p-4" aria-label="Next">‚Ä∫</button>
    <div class="max-w-[90vw] max-h-[90vh] flex flex-col items-center">
      <img id="lightbox-img" src="" alt="" class="max-w-full max-h-[85vh] object-contain rounded-lg shadow-2xl" />
      <p id="lightbox-title" class="mt-4 text-zinc-300 text-lg"></p>
    </div>
  </div>
</BaseLayout>

<style>
  .animate-pulse-slow {
    animation: pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  
  .lightbox-overlay {
    display: none;
  }

  .lightbox-overlay.active {
    display: flex;
  }

  /* Mobile touch improvements */
  .touch-manipulation {
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  /* Mobile: prevent odd text selection / highlight when tapping */
  .lightbox-trigger {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    user-select: none;
    /* allow vertical scrolling gestures to pass through without triggering "tap" */
    touch-action: pan-y;
  }

  .lightbox-trigger * {
    user-select: none;
    -webkit-user-select: none;
  }

  /* Prevent image drag on mobile */
  [data-lightbox] img {
    -webkit-user-drag: none;
    user-select: none;
  }
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { scrollbar-width: none; }

  .tag-pill {
    font-size: 12px;
    padding: 6px 10px;
    border-radius: 9999px;
    border: 1px solid rgba(39, 39, 42, 0.9);
    background: rgba(24, 24, 27, 0.35);
    color: rgba(161, 161, 170, 1);
    white-space: nowrap;
    transition: border-color 200ms ease, color 200ms ease, background 200ms ease;
  }
  .tag-pill:hover {
    border-color: rgba(168, 85, 247, 0.55);
    color: rgba(216, 180, 254, 1);
  }
  .tag-pill.active {
    border-color: rgba(168, 85, 247, 0.85);
    background: rgba(88, 28, 135, 0.25);
    color: rgba(216, 180, 254, 1);
  }

  .tag-chip {
    font-size: 12px;
    color: rgba(113, 113, 122, 1);
    transition: color 200ms ease;
  }
  .tag-chip:hover {
    color: rgba(192, 132, 252, 1);
  }
</style>

<script>
  // @ts-nocheck
  // Tumblr-ish tag filtering + progressive loading
  const grid = document.getElementById('gallery-grid');
  const loadMoreBtn = document.getElementById('load-more');
  const shownCountEl = document.getElementById('shown-count');
  const filterLabel = document.getElementById('gallery-filter-label');

  let activeTag = new URL(window.location.href).searchParams.get('tag') || '';
  let renderedCount = grid?.querySelectorAll('article[data-tags]').length ?? 0;

  // ---- tag filtering ----
  function setActiveTag(tag) {
    activeTag = tag;

    // only pills get the active styling
    document.querySelectorAll('.tag-pill').forEach((b) => {
      const t = b.getAttribute('data-filter-tag') || '';
      b.classList.toggle('active', t === activeTag);
    });

    // filter cards
    document.querySelectorAll('article[data-tags]').forEach((c) => {
      const tags = (c.getAttribute('data-tags') || '').split(/\s+/).filter(Boolean);
      const show = !activeTag || tags.includes(activeTag);
      c.style.display = show ? '' : 'none';
    });

    if (filterLabel) {
      filterLabel.textContent = activeTag ? `tag: #${activeTag}` : 'newest ‚Üí oldest';
    }

    const url = new URL(window.location.href);
    if (activeTag) url.searchParams.set('tag', activeTag);
    else url.searchParams.delete('tag');
    window.history.replaceState({}, '', url);
  }

  // click any tag anywhere
  document.addEventListener('click', (e) => {
    const el = e.target instanceof HTMLElement ? e.target.closest('[data-filter-tag]') : null;
    if (!el) return;
    const tag = el.getAttribute('data-filter-tag') || '';
    setActiveTag(tag);

    // if a top pill was clicked, jump to top (feels like switching feeds)
    if (el.classList.contains('tag-pill')) {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  });

  // ---- index loading ----
  let indexCache = null;
  async function getIndex() {
    if (indexCache) return indexCache;
    const res = await fetch('/gallery/index.json', { cache: 'no-store' });
    const json = await res.json();
    indexCache = (json && json.images) ? json.images : [];
    return indexCache;
  }

  function esc(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function renderCard(img) {
    const tags = (img.tags || []).map((t) => {
      return `<button type="button" class="tag-chip" data-filter-tag="${esc(t)}">#${esc(t)}</button>`;
    }).join('');

    return `
      <article class="group relative" data-tags="${esc((img.tags || []).join(' '))}" data-src="${esc(img.src)}">
        <div class="relative overflow-hidden rounded-lg bg-zinc-900 border border-zinc-800 hover:border-purple-500/50 transition-all duration-500">
          <button
            type="button"
            class="lightbox-trigger aspect-square w-full overflow-hidden cursor-pointer select-none touch-manipulation"
            data-lightbox="${esc(img.src)}"
            data-title="${esc(img.title || '')}"
            aria-label="Open ${esc(img.title || 'image')}"
          >
            <img
              src="${esc(img.thumb || img.src)}"
              alt="${esc(img.title || '')}"
              class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-700 pointer-events-none"
              loading="lazy"
              draggable="false"
            />
          </button>

          <div class="absolute inset-0 bg-gradient-to-t from-zinc-950 via-zinc-950/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex flex-col justify-end p-4 pointer-events-none">
            <h3 class="text-lg text-zinc-100 mb-1">${esc(img.title || '')}</h3>
            <p class="text-xs text-zinc-400 mb-2">${esc(img.description || '')}</p>
            <div class="flex items-center gap-2 text-xs text-zinc-600">
              <span class="font-mono">${esc(img.date || '')}</span>
              <span>¬∑</span>
              <span class="text-purple-400">${esc(img.model || '')}</span>
            </div>
          </div>
        </div>

        <div class="flex flex-wrap gap-2 mt-3">
          ${tags}
        </div>
      </article>
    `;
  }

  async function loadMore(batch = 24) {
    if (!grid) return;
    const imgs = await getIndex();
    const slice = imgs.slice(renderedCount, renderedCount + batch);
    if (!slice.length) {
      loadMoreBtn?.setAttribute('disabled', 'true');
      loadMoreBtn?.classList.add('opacity-40');
      return;
    }

    grid.insertAdjacentHTML('beforeend', slice.map(renderCard).join(''));
    renderedCount += slice.length;

    if (shownCountEl) shownCountEl.textContent = String(renderedCount);

    // hide button when done
    if (renderedCount >= imgs.length) {
      loadMoreBtn?.classList.add('hidden');
    }

    // Re-apply current filter and rebind lightbox triggers
    setActiveTag(activeTag);
    refreshLightboxTriggers();
  }

  loadMoreBtn?.addEventListener('click', () => loadMore());

  // ---- lightbox ----
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightbox-img');
  const lightboxTitle = document.getElementById('lightbox-title');
  const closeBtn = document.getElementById('lightbox-close');
  const prevBtn = document.getElementById('lightbox-prev');
  const nextBtn = document.getElementById('lightbox-next');

  let lbImages = [];
  let currentIndex = 0;

  function showImage(index) {
    if (!lbImages.length) return;
    if (index < 0) index = lbImages.length - 1;
    if (index >= lbImages.length) index = 0;
    currentIndex = index;
    if (lightboxImg) {
      lightboxImg.src = lbImages[index].src;
      lightboxImg.alt = lbImages[index].title || '';
    }
    if (lightboxTitle) lightboxTitle.textContent = lbImages[index].title || '';
  }

  function openLightboxBySrc(src) {
    const idx = lbImages.findIndex((i) => i.src === src);
    showImage(idx >= 0 ? idx : 0);
    lightbox?.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeLightbox() {
    lightbox?.classList.remove('active');
    document.body.style.overflow = '';
  }

  async function refreshLightboxTriggers() {
    lbImages = await getIndex();

    document.querySelectorAll('.lightbox-trigger[data-lightbox]').forEach((trigger) => {
      if (!(trigger instanceof HTMLElement)) return;
      if (trigger.dataset.bound === '1') return;
      trigger.dataset.bound = '1';

      // Tap-vs-scroll detection
      let startX = 0;
      let startY = 0;
      let moved = false;

      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = trigger.getAttribute('data-lightbox') || '';
        openLightboxBySrc(src);
      });

      trigger.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        startX = t.clientX;
        startY = t.clientY;
        moved = false;
      }, { passive: true });

      trigger.addEventListener('touchmove', (e) => {
        const t = e.changedTouches[0];
        const dx = Math.abs(t.clientX - startX);
        const dy = Math.abs(t.clientY - startY);
        if (dx > 8 || dy > 8) moved = true;
      }, { passive: true });

      trigger.addEventListener('touchend', (e) => {
        if (moved) return;
        e.preventDefault();
        e.stopPropagation();
        const src = trigger.getAttribute('data-lightbox') || '';
        openLightboxBySrc(src);
      }, { passive: false });
    });
  }

  closeBtn?.addEventListener('click', closeLightbox);
  prevBtn?.addEventListener('click', () => showImage(currentIndex - 1));
  nextBtn?.addEventListener('click', () => showImage(currentIndex + 1));

  lightbox?.addEventListener('click', (e) => {
    if (e.target === lightbox) closeLightbox();
  });

  document.addEventListener('keydown', (e) => {
    if (!lightbox?.classList.contains('active')) return;
    if (e.key === 'Escape') closeLightbox();
    if (e.key === 'ArrowLeft') showImage(currentIndex - 1);
    if (e.key === 'ArrowRight') showImage(currentIndex + 1);
  });

  // Touch swipe support for lightbox
  let touchStartX = 0;
  let touchEndX = 0;

  lightbox?.addEventListener('touchstart', (e) => {
    touchStartX = e.changedTouches[0].screenX;
  }, { passive: true });

  lightbox?.addEventListener('touchend', (e) => {
    touchEndX = e.changedTouches[0].screenX;
    const diff = touchStartX - touchEndX;
    if (Math.abs(diff) > 50) {
      if (diff > 0) showImage(currentIndex + 1);
      else showImage(currentIndex - 1);
    }
  }, { passive: true });

  // init
  setActiveTag(activeTag);
  refreshLightboxTriggers();
</script>
</script>
