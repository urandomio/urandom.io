<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Entropy Visualizer | urandom.io</title>
  <meta name="description" content="Live generative art from /dev/urandom">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>◉</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
    body { 
      font-family: 'JetBrains Mono', monospace;
      overflow: hidden;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    .ui-overlay {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-overlay * {
      pointer-events: auto;
    }
    
    .glass {
      backdrop-filter: blur(10px);
      background: rgba(0, 0, 0, 0.5);
    }
    
    .frozen-indicator {
      animation: pulse 1s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body class="bg-black text-zinc-300">
  
  <canvas id="canvas"></canvas>
  
  <!-- Header -->
  <header class="ui-overlay top-0 left-0 right-0 p-4 md:p-6 flex justify-between items-start">
    <a href="/" class="text-sm text-zinc-600 hover:text-zinc-400 transition-colors glass px-3 py-2 rounded">← back</a>
    <div class="text-right">
      <h1 class="text-lg md:text-xl font-light glass px-4 py-2 rounded">
        <span class="text-purple-400">entropy</span><span class="text-zinc-600">.visualizer</span>
      </h1>
    </div>
  </header>
  
  <!-- Status -->
  <div class="ui-overlay top-20 md:top-6 left-4 md:left-auto md:right-6 text-xs text-zinc-600 glass px-3 py-2 rounded">
    <div class="flex items-center gap-2">
      <span id="status-dot" class="w-2 h-2 rounded-full bg-green-500"></span>
      <span id="status-text">streaming entropy</span>
    </div>
    <div class="mt-1 text-zinc-700">
      <span id="entropy-counter">0</span> bytes visualized
    </div>
  </div>
  
  <!-- Controls -->
  <div class="ui-overlay bottom-4 md:bottom-6 left-4 right-4 md:left-6 md:right-auto">
    <div class="glass rounded-lg p-4 max-w-xs">
      <p class="text-xs text-zinc-500 mb-3">click canvas to freeze · space to resume</p>
      
      <div class="space-y-3">
        <div>
          <label class="text-xs text-zinc-600 block mb-1">mode</label>
          <select id="mode" class="w-full bg-zinc-900 border border-zinc-800 rounded px-2 py-1 text-sm text-zinc-300">
            <option value="flow">flow field</option>
            <option value="particles">particles</option>
            <option value="waves">wave interference</option>
            <option value="noise">perlin noise</option>
            <option value="cells">cellular</option>
          </select>
        </div>
        
        <div>
          <label class="text-xs text-zinc-600 block mb-1">palette</label>
          <select id="palette" class="w-full bg-zinc-900 border border-zinc-800 rounded px-2 py-1 text-sm text-zinc-300">
            <option value="void">void (purple/blue)</option>
            <option value="ember">ember (red/orange)</option>
            <option value="matrix">matrix (green)</option>
            <option value="mono">monochrome</option>
            <option value="rainbow">entropy rainbow</option>
          </select>
        </div>
        
        <div>
          <label class="text-xs text-zinc-600 block mb-1">speed</label>
          <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1" class="w-full">
        </div>
        
        <button id="save-btn" class="w-full bg-purple-600 hover:bg-purple-500 text-white text-sm py-2 rounded transition-colors">
          save pattern
        </button>
      </div>
    </div>
  </div>
  
  <!-- Frozen indicator -->
  <div id="frozen-overlay" class="ui-overlay inset-0 hidden items-center justify-center">
    <div class="glass px-6 py-3 rounded-lg frozen-indicator">
      <span class="text-purple-400">⏸</span> frozen · press space or click to resume
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let frozen = false;
    let entropyCount = 0;
    let animationId;
    let time = 0;
    
    // Palettes
    const palettes = {
      void: ['#1e1b4b', '#312e81', '#4c1d95', '#6d28d9', '#7c3aed', '#8b5cf6', '#a78bfa'],
      ember: ['#1c1917', '#292524', '#7c2d12', '#c2410c', '#ea580c', '#f97316', '#fb923c'],
      matrix: ['#022c22', '#064e3b', '#065f46', '#047857', '#059669', '#10b981', '#34d399'],
      mono: ['#09090b', '#18181b', '#27272a', '#3f3f46', '#52525b', '#71717a', '#a1a1aa'],
      rainbow: ['#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#8b5cf6', '#ec4899']
    };
    
    let currentPalette = palettes.void;
    let currentMode = 'flow';
    let speed = 1;
    
    // Resize handler
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    // Get random bytes from crypto API (backed by /dev/urandom)
    function getEntropy(n) {
      const bytes = new Uint8Array(n);
      crypto.getRandomValues(bytes);
      entropyCount += n;
      document.getElementById('entropy-counter').textContent = entropyCount.toLocaleString();
      return bytes;
    }
    
    // Get normalized random value
    function rand() {
      return getEntropy(1)[0] / 255;
    }
    
    // Get color from palette
    function getColor(t) {
      const i = Math.floor(t * (currentPalette.length - 1));
      return currentPalette[Math.min(i, currentPalette.length - 1)];
    }
    
    // Simple noise function
    function noise(x, y, t) {
      return (Math.sin(x * 0.01 + t) * Math.cos(y * 0.01 + t * 0.7) + 1) / 2;
    }
    
    // Perlin-like noise (simplified)
    function perlin(x, y) {
      const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
      return n - Math.floor(n);
    }
    
    // ===== MODES =====
    
    // Flow field
    function drawFlow() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
      ctx.fillRect(0, 0, width, height);
      
      const entropy = getEntropy(100);
      
      for (let i = 0; i < entropy.length; i += 2) {
        const x = (entropy[i] / 255) * width;
        const y = (entropy[i + 1] / 255) * height;
        const angle = noise(x, y, time * speed) * Math.PI * 2;
        const length = 20 + rand() * 30;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
        ctx.strokeStyle = getColor(noise(x, y, time * 0.5));
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    
    // Particles
    let particles = [];
    function initParticles() {
      particles = [];
      for (let i = 0; i < 500; i++) {
        particles.push({
          x: rand() * width,
          y: rand() * height,
          vx: (rand() - 0.5) * 2,
          vy: (rand() - 0.5) * 2,
          size: rand() * 3 + 1,
          color: getColor(rand())
        });
      }
    }
    
    function drawParticles() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, width, height);
      
      const entropy = getEntropy(20);
      let ei = 0;
      
      particles.forEach((p, i) => {
        // Add entropy influence
        if (i % 25 === 0 && ei < entropy.length - 1) {
          p.vx += (entropy[ei++] / 255 - 0.5) * 0.5;
          p.vy += (entropy[ei++] / 255 - 0.5) * 0.5;
        }
        
        p.x += p.vx * speed;
        p.y += p.vy * speed;
        
        // Wrap around
        if (p.x < 0) p.x = width;
        if (p.x > width) p.x = 0;
        if (p.y < 0) p.y = height;
        if (p.y > height) p.y = 0;
        
        // Dampen
        p.vx *= 0.99;
        p.vy *= 0.99;
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
      });
    }
    
    // Wave interference
    function drawWaves() {
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      const entropy = getEntropy(16);
      
      // Create wave sources from entropy
      const sources = [];
      for (let i = 0; i < entropy.length; i += 4) {
        sources.push({
          x: (entropy[i] / 255) * width,
          y: (entropy[i + 1] / 255) * height,
          freq: entropy[i + 2] / 50,
          phase: entropy[i + 3] / 255 * Math.PI * 2
        });
      }
      
      for (let y = 0; y < height; y += 2) {
        for (let x = 0; x < width; x += 2) {
          let val = 0;
          sources.forEach(s => {
            const d = Math.sqrt((x - s.x) ** 2 + (y - s.y) ** 2);
            val += Math.sin(d * s.freq + time * speed + s.phase);
          });
          
          val = (val / sources.length + 1) / 2;
          const color = currentPalette[Math.floor(val * (currentPalette.length - 1))];
          const rgb = hexToRgb(color);
          
          const idx = (y * width + x) * 4;
          data[idx] = rgb.r;
          data[idx + 1] = rgb.g;
          data[idx + 2] = rgb.b;
          data[idx + 3] = 255;
          
          // Fill 2x2 block for performance
          if (x + 1 < width) {
            data[idx + 4] = rgb.r; data[idx + 5] = rgb.g; data[idx + 6] = rgb.b; data[idx + 7] = 255;
          }
          if (y + 1 < height) {
            const idx2 = ((y + 1) * width + x) * 4;
            data[idx2] = rgb.r; data[idx2 + 1] = rgb.g; data[idx2 + 2] = rgb.b; data[idx2 + 3] = 255;
            if (x + 1 < width) {
              data[idx2 + 4] = rgb.r; data[idx2 + 5] = rgb.g; data[idx2 + 6] = rgb.b; data[idx2 + 7] = 255;
            }
          }
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    // Perlin noise field
    function drawNoise() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      const scale = 0.005;
      const entropy = getEntropy(4);
      const offsetX = entropy[0] / 255 * 100;
      const offsetY = entropy[1] / 255 * 100;
      
      for (let y = 0; y < height; y += 8) {
        for (let x = 0; x < width; x += 8) {
          const n = perlin((x + offsetX + time * 50 * speed) * scale, (y + offsetY) * scale);
          const n2 = perlin((x + offsetX) * scale * 2, (y + offsetY + time * 30 * speed) * scale * 2);
          const val = (n + n2) / 2;
          
          ctx.fillStyle = getColor(val);
          ctx.globalAlpha = 0.3;
          ctx.fillRect(x, y, 8, 8);
        }
      }
      ctx.globalAlpha = 1;
    }
    
    // Cellular automata-ish
    function drawCells() {
      const cellSize = 10;
      const cols = Math.ceil(width / cellSize);
      const rows = Math.ceil(height / cellSize);
      const entropy = getEntropy(cols * rows / 8);
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
      ctx.fillRect(0, 0, width, height);
      
      let ei = 0;
      let bit = 0;
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          // Use entropy bits
          const alive = (entropy[ei] >> bit) & 1;
          bit++;
          if (bit >= 8) { bit = 0; ei = (ei + 1) % entropy.length; }
          
          if (alive || Math.random() < 0.01) {
            const val = noise(x * 20, y * 20, time * speed);
            ctx.fillStyle = getColor(val);
            ctx.globalAlpha = 0.5;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
          }
        }
      }
      ctx.globalAlpha = 1;
    }
    
    // Hex to RGB helper
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 0, g: 0, b: 0 };
    }
    
    // Main draw loop
    function draw() {
      if (frozen) return;
      
      time += 0.016;
      
      switch (currentMode) {
        case 'flow': drawFlow(); break;
        case 'particles': drawParticles(); break;
        case 'waves': drawWaves(); break;
        case 'noise': drawNoise(); break;
        case 'cells': drawCells(); break;
      }
      
      animationId = requestAnimationFrame(draw);
    }
    
    // Toggle freeze
    function toggleFreeze() {
      frozen = !frozen;
      const overlay = document.getElementById('frozen-overlay');
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      
      if (frozen) {
        overlay.classList.remove('hidden');
        overlay.classList.add('flex');
        dot.classList.remove('bg-green-500');
        dot.classList.add('bg-yellow-500');
        text.textContent = 'frozen';
      } else {
        overlay.classList.add('hidden');
        overlay.classList.remove('flex');
        dot.classList.remove('bg-yellow-500');
        dot.classList.add('bg-green-500');
        text.textContent = 'streaming entropy';
        draw();
      }
    }
    
    // Save pattern
    function savePattern() {
      const link = document.createElement('a');
      link.download = `entropy-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }
    
    // Event listeners
    canvas.addEventListener('click', toggleFreeze);
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        toggleFreeze();
      }
    });
    
    document.getElementById('mode').addEventListener('change', (e) => {
      currentMode = e.target.value;
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, width, height);
      if (currentMode === 'particles') initParticles();
    });
    
    document.getElementById('palette').addEventListener('change', (e) => {
      currentPalette = palettes[e.target.value];
      if (currentMode === 'particles') {
        particles.forEach(p => p.color = getColor(rand()));
      }
    });
    
    document.getElementById('speed').addEventListener('input', (e) => {
      speed = parseFloat(e.target.value);
    });
    
    document.getElementById('save-btn').addEventListener('click', savePattern);
    
    window.addEventListener('resize', resize);
    
    // Init
    resize();
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width, height);
    draw();
    
    // Console
    console.log('%c◉ Entropy Visualizer', 'font-size: 16px; color: #a855f7;');
    console.log('%cPowered by crypto.getRandomValues() → /dev/urandom', 'color: #666;');
  </script>
</body>
</html>
